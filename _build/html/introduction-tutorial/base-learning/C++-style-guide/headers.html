<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>1. 头文件 &mdash; IMCA-VISION_DOCUMENTATION v1.2 文档</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=7fb3a1ff"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/translations.js?v=beaddf03"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../../genindex.html" />
    <link rel="search" title="搜索" href="../../../search.html" />
    <link rel="next" title="2. 作用域" href="scoping.html" />
    <link rel="prev" title="c++代码风格规范" href="../C%2B%2B-style-guide.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            IMCA-VISION_DOCUMENTATION
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../../root/introduction-tutorial.html">教程</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../base-learning.html">入门</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../ubuntu-install.html">Ubuntu (22.04版本)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../start-in-ubuntu.html">开始使用Ubuntu</a></li>
<li class="toctree-l3"><a class="reference internal" href="../VPN.html">关于vpn</a></li>
<li class="toctree-l3"><a class="reference internal" href="../the-IDE.html">IDE的安装和配置</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cmake-tool.html">cmake安装和基本使用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../git-and-github.html">Git和github</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../C%2B%2B-style-guide.html">c++代码风格规范</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">1. 头文件</a></li>
<li class="toctree-l4"><a class="reference internal" href="scoping.html">2. 作用域</a></li>
<li class="toctree-l4"><a class="reference internal" href="classes.html">3. 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="functions.html">4. 函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="magic.html">5. 来自 Google 的奇技</a></li>
<li class="toctree-l4"><a class="reference internal" href="others.html">6. 其他 C++ 特性</a></li>
<li class="toctree-l4"><a class="reference internal" href="naming.html">7. 命名约定</a></li>
<li class="toctree-l4"><a class="reference internal" href="comments.html">8. 注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="formatting.html">9. 格式</a></li>
<li class="toctree-l4"><a class="reference internal" href="exceptions.html">10. 规则特例</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../advanced-teaching.html">进阶</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../root/quick-start.html">快速开始</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../root/ros-co-simulation.html">ros联合仿真</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">IMCA-VISION_DOCUMENTATION</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../root/introduction-tutorial.html">教程</a></li>
          <li class="breadcrumb-item"><a href="../../base-learning.html">入门</a></li>
          <li class="breadcrumb-item"><a href="../C%2B%2B-style-guide.html">c++代码风格规范</a></li>
      <li class="breadcrumb-item active">1. 头文件</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>1. 头文件<a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
<p>通常每个 <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> 文件应该有一个配套的 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 文件. 常见的例外情况包括单元测试和仅有 <code class="docutils literal notranslate"><span class="pre">main()</span></code> 函数的 <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> 文件.</p>
<p>正确使用头文件会大大改善代码的可读性和执行文件的大小、性能.</p>
<p>下面的规则将带你规避头文件的各种误区.</p>
<section id="self-contained-headers">
<span id="id2"></span><h2>1.1. 自给自足的头文件<a class="headerlink" href="#self-contained-headers" title="Link to this heading"></a></h2>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>头文件应该自给自足 (self-contained, 也就是可以独立编译), 并以 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 为扩展名. 给需要被导入 (include) 但不属于头文件的文件设置为 <code class="docutils literal notranslate"><span class="pre">.inc</span></code> 扩展名, 并尽量避免使用.</p>
</div>
<p>所有头文件应该自给自足, 也就是头文件的使用者和重构工具在导入文件时无需任何特殊的前提条件. 具体来说, 头文件要有头文件防护符 (header guards, <a class="reference internal" href="#define-guard"><span class="std std-ref">1.2. #define 防护符</span></a>)，并导入它所需的所有其它头文件.</p>
<p>若头文件声明了内联函数 (inline function) 或模版 (template), 而且头文件的使用者需要实例化 (instantiate) 这些组件时, 头文件必须直接或通过导入的文件间接提供这些组件的实现 (definition). 不要把这些实现放到另一个头文件里 (例如 <code class="docutils literal notranslate"><span class="pre">-inl.h</span></code> 文件) 再导入进来; 这是过去的惯例, 但现在被禁止了. 若模版的所有实例化过程都仅出现在一个 <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> 文件中, 比如采用显式 (explicit) 实例化, 或者只有这个 <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> 文件会用到模版定义 (definition), 那么可以把模版的定义放在这个文件里.</p>
<p>在少数情况下, 用于导入的文件不能自给自足. 它们通常是要在特殊的地方导入, 例如另一个文件中间的某处. 此类文件不需要使用头文件防护符, 也不需要导入它的依赖 (prerequisite). 此类文件应该使用 <code class="docutils literal notranslate"><span class="pre">.inc</span></code> 扩展名. 尽量少用这种文件, 可行时应该采用自给自足的头文件.</p>
</section>
<section id="define">
<span id="define-guard"></span><h2>1.2. #define 防护符<a class="headerlink" href="#define" title="Link to this heading"></a></h2>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>所有头文件都应该用 <code class="docutils literal notranslate"><span class="pre">#define</span></code> 防护符来防止重复导入. 防护符的格式是: <code class="docutils literal notranslate"><span class="pre">&lt;项目&gt;_&lt;路径&gt;_&lt;文件名&gt;_H_</span></code> .</p>
</div>
<p>为了保证符号的唯一性, 防护符的名称应该基于该文件在项目目录中的完整文件路径. 例如, <code class="docutils literal notranslate"><span class="pre">foo</span></code> 项目中的文件 <code class="docutils literal notranslate"><span class="pre">foo/src/bar/baz.h</span></code> 应该有如下防护:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef FOO_BAR_BAZ_H_</span>
<span class="cp">#define FOO_BAR_BAZ_H_</span>
<span class="p">...</span>
<span class="cp">#endif  </span><span class="c1">// FOO_BAR_BAZ_H_</span>
</pre></div>
</div>
</section>
<section id="include-what-you-use">
<span id="id3"></span><h2>1.3. 导入你的依赖<a class="headerlink" href="#include-what-you-use" title="Link to this heading"></a></h2>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>若代码文件或头文件引用了其他地方定义的符号 (symbol), 该文件应该直接导入 (include) 提供该符号的声明 (declaration) 或者定义 (definition) 的头文件. 不应该为了其他原因而导入头文件.</p>
</div>
<p>不要依赖间接导入. 这样, 人们删除不再需要的 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 语句时, 才不会影响使用者. 此规则也适用于配套的文件: 若 <code class="docutils literal notranslate"><span class="pre">foo.cpp</span></code> 使用了 <code class="docutils literal notranslate"><span class="pre">bar.h</span></code> 的符号, 就需要导入 <code class="docutils literal notranslate"><span class="pre">bar.h</span></code>, 即使 <code class="docutils literal notranslate"><span class="pre">foo.h</span></code> 已经导入了 <code class="docutils literal notranslate"><span class="pre">bar.h</span></code>.</p>
</section>
<section id="forward-declarations">
<span id="id4"></span><h2>1.4. 前向声明<a class="headerlink" href="#forward-declarations" title="Link to this heading"></a></h2>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>尽量避免使用前向声明. 应该 <a class="reference internal" href="#include-what-you-use"><span class="std std-ref">导入你所需的头文件</span></a>。</p>
</div>
<p><strong>定义：</strong></p>
<blockquote>
<div><p>前向声明 (forward declaration) 是没有对应定义 (definition) 的声明.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 在 C++ 源码文件中：</span>
<span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">FuncInB</span><span class="p">();</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">variable_in_b</span><span class="p">;</span>
<span class="n">ABSL_DECLARE_FLAG</span><span class="p">(</span><span class="n">flag_in_b</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>优点：</strong></p>
<blockquote>
<div><ul class="simple">
<li><p>使用前向声明能节约编译时间, 因为 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 会迫使编译器打开更多的文件并处理更多的输入.</p></li>
<li><p>使用前向声明能避免不必要的重复编译. 若使用 <code class="docutils literal notranslate"><span class="pre">#include</span></code>, 头文件中无关的改动也会触发重新编译.</p></li>
</ul>
</div></blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<div><ul>
<li><p>前向声明隐藏了依赖关系, 可能会让人忽略头文件变化后必要的重新编译过程.</p></li>
<li><p>相比 <code class="docutils literal notranslate"><span class="pre">#include</span></code>, 前向声明的存在会让自动化工具难以发现定义该符号的模块.</p></li>
<li><p>修改库 (library) 时可能破坏前向声明. 函数或模板的前向声明会阻碍头文件的负责人修改 API, 例如拓宽 (widening) 参数类型, 为模版参数添加默认值, 迁移到新的命名空间等等, 而这些操作本是无碍的.</p></li>
<li><p>为 <code class="docutils literal notranslate"><span class="pre">std::</span></code> 命名空间的符号提供前向声明会产生未定义行为 (undefined behavior).</p></li>
<li><p>很难判断什么时候该用前向声明, 什么时候该用 <code class="docutils literal notranslate"><span class="pre">#include</span></code> . 用前向声明代替 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 时, 可能会悄然改变代码的含义:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// b.h:</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="p">{};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">D</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{};</span>

<span class="c1">// good_user.cc:</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;b.h&quot;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">B</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">test</span><span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// 调用 f(B*)</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
<blockquote>
<div><p>若用 <code class="docutils literal notranslate"><span class="pre">B</span></code> 和 <code class="docutils literal notranslate"><span class="pre">D</span></code> 的前向声明替代 <code class="docutils literal notranslate"><span class="pre">#include</span></code>, <code class="docutils literal notranslate"><span class="pre">test()</span></code> 会调用 <code class="docutils literal notranslate"><span class="pre">f(void*)</span></code> .</p>
</div></blockquote>
<ul class="simple">
<li><p>为多个符号添加前向声明比直接 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 更冗长.</p></li>
<li><p>为兼容前向声明而设计的代码 (比如用指针成员代替对象成员) 更慢更复杂.</p></li>
</ul>
</div></blockquote>
<p><strong>结论：</strong></p>
<p>尽量避免为其他项目定义的实体提供前向声明.</p>
</section>
<section id="inline-functions">
<span id="id5"></span><h2>1.5. 内联函数<a class="headerlink" href="#inline-functions" title="Link to this heading"></a></h2>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>只把 10 行以下的小函数定义为内联 (inline).</p>
</div>
<p><strong>定义:</strong></p>
<blockquote>
<div><p>你可以通过声明让编译器展开内联函数, 而不是使用正常的函数调用机制.</p>
</div></blockquote>
<p><strong>优点:</strong></p>
<blockquote>
<div><p>只要内联函数体积较小, 内联函数可以令目标代码 (object code) 更加高效. 我们鼓励对存取函数 (accessors)、变异函数 (mutators) 和其它短小且影响性能的函数使用内联展开.</p>
</div></blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<div><p>滥用内联将拖慢程序. 根据函数体积, 内联可能会增加或减少代码体积. 通常, 内联展开非常短小的存取函数会减少代码大小, 但内联一个巨大的函数将显著增加代码大小. 在现代处理器上, 通常代码越小执行越快, 因为指令缓存利用率高.</p>
</div></blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<div><p>合理的经验法则是不要内联超过 10 行的函数. 谨慎对待析构函数. 析构函数往往比表面上更长, 因为会暗中调用成员和基类的析构函数!</p>
<p>另一个实用的经验准则: 内联那些有循环或 <code class="docutils literal notranslate"><span class="pre">switch</span></code> 语句的函数通常得不偿失 (除非这些循环或 <code class="docutils literal notranslate"><span class="pre">switch</span></code> 语句通常不执行).</p>
<p>应该注意, 即使函数被声明为内联函数, 也不一定真的会被内联; 比如, 通常虚函数和递归函数不会被内联. 通常不应该声明递归函数为内联. (YuleFox 注: 递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 为虚函数声明内联的主要目的是在类 (class) 中定义该函数, 以便于使用该函数或注释其行为. 这常用于存取函数和变异函数.</p>
</div></blockquote>
</section>
<section id="include">
<span id="name-and-order-of-includes"></span><h2>1.6. <code class="docutils literal notranslate"><span class="pre">#include</span></code> 的路径及顺序<a class="headerlink" href="#include" title="Link to this heading"></a></h2>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>推荐按照以下顺序导入头文件: 配套的头文件, C 语言系统库头文件, C++ 标准库头文件, 其他库的头文件, 本项目的头文件.</p>
</div>
<p>头文件的路径应相对于项目源码目录, 不能出现 UNIX 目录别名 (alias) <code class="docutils literal notranslate"><span class="pre">.</span></code> (当前目录) 或 <code class="docutils literal notranslate"><span class="pre">..</span></code> (上级目录). 例如, 应该按如下方式导入 <code class="docutils literal notranslate"><span class="pre">google-awesome-project/src/base/logging.h</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;base/logging.h&quot;</span>
</pre></div>
</div>
<p>在 <code class="docutils literal notranslate"><span class="pre">dir/foo.cc</span></code> 或 <code class="docutils literal notranslate"><span class="pre">dir/foo_test.cc</span></code> 这两个实现或测试 <code class="docutils literal notranslate"><span class="pre">dir2/foo2.h</span></code> 内容的文件中, 按如下顺序导入头文件:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">dir2/foo2.h</span></code>.</p></li>
<li><p>空行</p></li>
<li><p>C 语言系统文件 (确切地说: 用使用方括号和 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 扩展名的头文件), 例如 <code class="docutils literal notranslate"><span class="pre">&lt;unistd.h&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&lt;stdlib.h&gt;</span></code>.</p></li>
<li><p>空行</p></li>
<li><p>C++ 标准库头文件 (不含扩展名), 例如 <code class="docutils literal notranslate"><span class="pre">&lt;algorithm&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&lt;cstddef&gt;</span></code>.</p></li>
<li><p>空行</p></li>
<li><p>其他库的 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 文件.</p></li>
<li><p>空行</p></li>
<li><p>本项目的 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 文件.</p></li>
</ol>
</div></blockquote>
<p>每个非空的分组之间用空行隔开.</p>
<p>这种顺序可以确保在 <code class="docutils literal notranslate"><span class="pre">dir2/foo2.h</span></code> 缺少必要的导入时, 构建 (build) <code class="docutils literal notranslate"><span class="pre">dir/foo.cpp</span></code> 或 <code class="docutils literal notranslate"><span class="pre">dir/foo_test.cpp</span></code> 会失败. 这样维护这些文件的人会首先发现构建失败, 而不是维护其他库的无辜的人.</p>
<p><code class="docutils literal notranslate"><span class="pre">dir/foo.cpp</span></code> 和 <code class="docutils literal notranslate"><span class="pre">dir2/foo2.h</span></code> 通常位于同一目录下 (如 <code class="docutils literal notranslate"><span class="pre">base/basictypes_unittest.cpp</span></code> 和 <code class="docutils literal notranslate"><span class="pre">base/basictypes.h</span></code>), 但有时也放在不同目录下.</p>
<p>注意 C 语言头文件 (如 <code class="docutils literal notranslate"><span class="pre">stddef.h</span></code>) 和对应的 C++ 头文件 (<code class="docutils literal notranslate"><span class="pre">cstddef</span></code>) 是等效的. 两种风格都可以接受, 但是最好和现有代码保持一致.</p>
<p>每个分组内部的导入语句应该按字母序排列. 注意旧代码可能没有遵守这条规则, 应该在方便时进行修正.</p>
<p>举例来说, <code class="docutils literal notranslate"><span class="pre">google-awesome-project/src/foo/internal/fooserver.cpp</span></code> 的导入语句如下:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;foo/server/fooserver.h&quot;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/types.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unistd.h&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;base/basictypes.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;foo/server/bar.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;third_party/absl/flags/flag.h&quot;</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>例外：</strong></p>
<p>有时平台相关的 (system-specific) 代码需要有条件地导入 (conditional include)，此时可以在其他导入语句后放置条件导入语句. 当然, 尽量保持平台相关的代码简洁且影响范围小. 例如：</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;foo/public/fooserver.h&quot;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;base/port.h&quot;</span><span class="c1">  // 为了 LANG_CXX11.</span>

<span class="cp">#ifdef LANG_CXX11</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;initializer_list&gt;</span>
<span class="cp">#endif  </span><span class="c1">// LANG_CXX11</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="yulefox">
<h2>译者 (YuleFox) 笔记<a class="headerlink" href="#yulefox" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>避免多重包含是学编程时最基本的要求;</p></li>
<li><p>前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应;</p></li>
<li><p>内联函数的合理使用可提高代码执行效率;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-inl.h</span></code> 可提高代码可读性 (一般用不到吧:D);</p></li>
<li><p>标准化函数参数顺序可以提高可读性和易维护性 (对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放在一起);</p></li>
<li><p>包含文件的名称使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 和 <code class="docutils literal notranslate"><span class="pre">..</span></code> 虽然方便却易混乱, 使用比较完整的项目路径看上去很清晰, 很条理, 包含文件的次序除了美观之外, 最重要的是可以减少隐藏依赖, 使每个头文件在 “最需要编译” (对应源文件处 :D) 的地方编译, 有人提出库文件放在最后, 这样出错先是项目内的文件, 头文件都放在对应源文件的最前面, 这一点足以保证内部错误的及时发现了.</p></li>
</ol>
</section>
<section id="acgtyrant">
<h2>译者（acgtyrant）笔记<a class="headerlink" href="#acgtyrant" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>原来还真有项目用 <code class="docutils literal notranslate"><span class="pre">#includes</span></code> 来插入文本，且其文件扩展名 <code class="docutils literal notranslate"><span class="pre">.inc</span></code> 看上去也很科学。</p></li>
<li><p>Google 已经不再提倡 <code class="docutils literal notranslate"><span class="pre">-inl.h</span></code> 用法。</p></li>
<li><p>注意，前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。</p></li>
<li><p>类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。</p></li>
<li><p>在 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 和本项目内的 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 是个好习惯。</p></li>
</ol>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="../C%2B%2B-style-guide.html" class="btn btn-neutral float-left" title="c++代码风格规范" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="scoping.html" class="btn btn-neutral float-right" title="2. 作用域" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2024, IMCA_VISION。</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>